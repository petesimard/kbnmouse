<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∫ Thai Tuk-Tuk Taxi!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }

        #ui-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 20px; left: 20px; right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-box {
            background: rgba(0,0,0,0.6);
            border-radius: 16px;
            padding: 12px 24px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            border: 3px solid rgba(255,255,255,0.2);
        }

        #money-display { color: #FFD700; font-size: 28px; }
        #timer-display { color: #FF6B9D; }
        #passengers-display { color: #7FDBFF; }

        #mission-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            border-radius: 20px;
            padding: 20px 40px;
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            border: 3px solid #FFD700;
        }
        #mission-banner.show { opacity: 1; }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.5);
            overflow: hidden;
            background: rgba(34, 100, 34, 0.8);
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Title Screen */
        #title-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #FF6B9D 0%, #FFB347 25%, #FF6B9D 50%, #C44DFF 75%, #FFB347 100%);
            background-size: 400% 400%;
            animation: gradientShift 4s ease infinite;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #title-screen h1 {
            font-size: 72px;
            color: white;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.3), 0 0 40px rgba(255,215,0,0.5);
            margin-bottom: 10px;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        #title-screen h2 {
            font-size: 32px;
            color: #FFF8DC;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 40px;
        }

        .title-emoji {
            font-size: 80px;
            margin-bottom: 20px;
            animation: spin 3s ease-in-out infinite;
        }

        @keyframes spin {
            0%, 100% { transform: rotate(-5deg) scale(1); }
            50% { transform: rotate(5deg) scale(1.1); }
        }

        #start-btn {
            font-size: 36px;
            padding: 20px 60px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            font-weight: bold;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }

        #start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4);
        }

        .instructions {
            margin-top: 30px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 20px 40px;
            color: white;
            font-size: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .instructions div {
            margin: 8px 0;
        }

        .key-hint {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 2px 10px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        /* Game Over Screen */
        #gameover-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }

        #gameover-screen.show {
            display: flex;
        }

        #gameover-screen h1 {
            font-size: 56px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        .final-stats {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px 50px;
            margin: 20px;
            text-align: center;
        }

        .final-stats div {
            font-size: 28px;
            color: white;
            margin: 12px 0;
        }

        #restart-btn {
            font-size: 30px;
            padding: 16px 50px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, #FF6B9D, #C44DFF);
            color: white;
            font-weight: bold;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.2s;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            margin-top: 20px;
        }

        #restart-btn:hover {
            transform: scale(1.1);
        }

        /* Pickup indicator */
        #pickup-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 0, 0.85);
            color: white;
            font-size: 28px;
            font-weight: bold;
            padding: 14px 40px;
            border-radius: 50px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 3px solid #00FF00;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        #pickup-prompt.show { opacity: 1; }

        /* Combo display */
        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }

        #combo-display.show {
            opacity: 1;
            transform: translate(-50%, -70%);
        }
    </style>
</head>
<body>

<!-- Title Screen -->
<div id="title-screen">
    <div class="title-emoji">üõ∫</div>
    <h1>Thai Tuk-Tuk Taxi!</h1>
    <h2>üáπüá≠ Bangkok Adventure üáπüá≠</h2>
    <button id="start-btn" onclick="startGame()">üö¶ START DRIVING! üö¶</button>
    <div class="instructions">
        <div><span class="key-hint">‚Üë</span> <span class="key-hint">W</span> Accelerate &nbsp; <span class="key-hint">‚Üì</span> <span class="key-hint">S</span> Brake</div>
        <div><span class="key-hint">‚Üê</span> <span class="key-hint">A</span> Turn Left &nbsp; <span class="key-hint">‚Üí</span> <span class="key-hint">D</span> Turn Right</div>
        <div><span class="key-hint">SPACE</span> Pick Up / Drop Off Passengers</div>
        <div style="margin-top: 12px; color: #FFD700;">üéØ Pick up passengers and deliver them to earn money!</div>
        <div style="color: #FF6B9D;">‚è±Ô∏è You have 2 minutes ‚Äî earn as much as you can!</div>
    </div>
</div>

<!-- Game Over Screen -->
<div id="gameover-screen">
    <h1>üèÅ Time's Up! üèÅ</h1>
    <div class="final-stats">
        <div>üí∞ Total Earnings: <span id="final-money" style="color:#FFD700;">‡∏ø0</span></div>
        <div>üßë‚Äçü§ù‚Äçüßë Passengers Delivered: <span id="final-passengers" style="color:#7FDBFF;">0</span></div>
        <div>‚≠ê Rating: <span id="final-rating" style="color:#FF6B9D;">-</span></div>
    </div>
    <button id="restart-btn" onclick="restartGame()">üîÑ Drive Again!</button>
</div>

<!-- In-Game UI -->
<div id="ui-overlay">
    <div id="hud" style="display:none;">
        <div class="hud-box" id="money-display">üí∞ ‡∏ø0</div>
        <div class="hud-box" id="timer-display">‚è±Ô∏è 2:00</div>
        <div class="hud-box" id="passengers-display">üßë 0 delivered</div>
    </div>
    <div id="mission-banner"></div>
    <div id="pickup-prompt">Press SPACE to pick up! üõ∫</div>
    <div id="combo-display"></div>
</div>

<!-- Minimap -->
<div id="minimap" style="display:none;">
    <canvas id="minimap-canvas" width="180" height="180"></canvas>
</div>

<script>
// ============ GAME STATE ============
const GAME_DURATION = 120; // seconds
const MAP_SIZE = 300;
const ROAD_WIDTH = 12;
const BUILDING_ZONE = 25;

let scene, camera, renderer, clock;
let tuktuk, tuktukGroup;
let speed = 0, turnSpeed = 0;
let maxSpeed = 0.5;
let acceleration = 0.015;
let brakeForce = 0.03;
let friction = 0.008;
let turnRate = 0.035;
let money = 0;
let passengersDelivered = 0;
let timeLeft = GAME_DURATION;
let gameRunning = false;
let gameStarted = false;

// Passenger system
let passengers = [];
let currentPassenger = null; // passenger we're carrying
let dropoffMarker = null;
let nearbyPassenger = null;
let nearDropoff = false;
let comboCount = 0;
let comboTimer = 0;

// World objects
let buildings = [];
let trees = [];
let roads = [];
let decorations = [];

// Input
const keys = {};

// Audio context
let audioCtx;

// Particle system
let particles = [];

// ============ INITIALIZATION ============
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 150, 350);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.insertBefore(renderer.domElement, document.body.firstChild);

    clock = new THREE.Clock();

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff5e6, 0.9);
    sunLight.position.set(50, 80, 30);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 300;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x556B2F, 0.4);
    scene.add(hemiLight);

    // Ground
    createGround();

    // Roads
    createRoads();

    // Buildings
    createBuildings();

    // Trees & decorations
    createTrees();
    createDecorations();

    // Tuk-Tuk
    createTukTuk();

    // Passengers
    spawnPassengers(8);

    // Events
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; keys[e.code] = true; });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; keys[e.code] = false; });

    // Audio
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    animate();
}

// ============ WORLD CREATION ============
function createGround() {
    // Main grass ground
    const groundGeo = new THREE.PlaneGeometry(MAP_SIZE * 2, MAP_SIZE * 2);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.1;
    ground.receiveShadow = true;
    scene.add(ground);

    // Water around edges (like canals - very Thai!)
    const waterGeo = new THREE.PlaneGeometry(MAP_SIZE * 3, MAP_SIZE * 3);
    const waterMat = new THREE.MeshLambertMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.8 });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    water.position.y = -0.5;
    scene.add(water);
}

// Road layout: grid system
const roadPaths = [];

function createRoads() {
    const roadMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
    const sidewalkMat = new THREE.MeshLambertMaterial({ color: 0xBDBDBD });
    const lineMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });

    // Horizontal roads
    const hRoads = [-80, -30, 20, 70];
    // Vertical roads
    const vRoads = [-80, -30, 20, 70];

    hRoads.forEach(z => {
        // Road surface
        const roadGeo = new THREE.BoxGeometry(MAP_SIZE * 1.5, 0.1, ROAD_WIDTH);
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.position.set(0, 0.01, z);
        road.receiveShadow = true;
        scene.add(road);
        roads.push(road);

        // Center line
        for (let x = -MAP_SIZE * 0.7; x < MAP_SIZE * 0.7; x += 8) {
            const lineGeo = new THREE.BoxGeometry(4, 0.05, 0.3);
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.set(x, 0.12, z);
            scene.add(line);
        }

        // Sidewalks
        [-1, 1].forEach(side => {
            const swGeo = new THREE.BoxGeometry(MAP_SIZE * 1.5, 0.3, 2);
            const sw = new THREE.Mesh(swGeo, sidewalkMat);
            sw.position.set(0, 0.15, z + side * (ROAD_WIDTH / 2 + 1));
            sw.receiveShadow = true;
            scene.add(sw);
        });

        roadPaths.push({ type: 'h', z: z, minX: -MAP_SIZE * 0.7, maxX: MAP_SIZE * 0.7 });
    });

    vRoads.forEach(x => {
        const roadGeo = new THREE.BoxGeometry(ROAD_WIDTH, 0.1, MAP_SIZE * 1.5);
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.position.set(x, 0.02, 0);
        road.receiveShadow = true;
        scene.add(road);
        roads.push(road);

        for (let z = -MAP_SIZE * 0.7; z < MAP_SIZE * 0.7; z += 8) {
            const lineGeo = new THREE.BoxGeometry(0.3, 0.05, 4);
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.set(x, 0.12, z);
            scene.add(line);
        }

        [-1, 1].forEach(side => {
            const swGeo = new THREE.BoxGeometry(2, 0.3, MAP_SIZE * 1.5);
            const sw = new THREE.Mesh(swGeo, sidewalkMat);
            sw.position.set(x + side * (ROAD_WIDTH / 2 + 1), 0.15, 0);
            sw.receiveShadow = true;
            scene.add(sw);
        });

        roadPaths.push({ type: 'v', x: x, minZ: -MAP_SIZE * 0.7, maxZ: MAP_SIZE * 0.7 });
    });
}

function createBuildings() {
    const colors = [
        0xFF6B9D, 0xFFB347, 0x7FDBFF, 0xB39DDB, 0xFF8A65,
        0x81C784, 0xFFD54F, 0xF48FB1, 0x80DEEA, 0xE6EE9C,
        0xFFCC02, 0xFF5252, 0x69F0AE, 0x448AFF, 0xEA80FC
    ];

    const hRoads = [-80, -30, 20, 70];
    const vRoads = [-80, -30, 20, 70];

    // Place buildings in blocks between roads
    for (let bx = 0; bx < hRoads.length - 1; bx++) {
        for (let bz = 0; bz < vRoads.length - 1; bz++) {
            const blockMinX = vRoads[bx] + ROAD_WIDTH / 2 + 3;
            const blockMaxX = vRoads[bx + 1] - ROAD_WIDTH / 2 - 3;
            const blockMinZ = hRoads[bz] + ROAD_WIDTH / 2 + 3;
            const blockMaxZ = hRoads[bz + 1] - ROAD_WIDTH / 2 - 3;

            const numBuildings = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numBuildings; i++) {
                const w = 4 + Math.random() * 10;
                const d = 4 + Math.random() * 10;
                const h = 3 + Math.random() * 15;
                const x = blockMinX + Math.random() * (blockMaxX - blockMinX - w);
                const z = blockMinZ + Math.random() * (blockMaxZ - blockMinZ - d);

                const color = colors[Math.floor(Math.random() * colors.length)];
                createBuilding(x + w / 2, z + d / 2, w, h, d, color);
            }
        }
    }

    // Special Thai temples
    createTemple(-55, -55, 0xFFD700);
    createTemple(45, 45, 0xFF6B00);
    createTemple(-5, 45, 0xE91E63);
}

function createBuilding(x, z, w, h, d, color) {
    const group = new THREE.Group();

    // Main body
    const bodyGeo = new THREE.BoxGeometry(w, h, d);
    const bodyMat = new THREE.MeshLambertMaterial({ color: color });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.set(0, h / 2, 0);
    body.castShadow = true;
    body.receiveShadow = true;
    group.add(body);

    // Roof
    const roofColor = new THREE.Color(color).multiplyScalar(0.7);
    const roofGeo = new THREE.BoxGeometry(w + 1, 0.5, d + 1);
    const roofMat = new THREE.MeshLambertMaterial({ color: roofColor });
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(0, h + 0.25, 0);
    roof.castShadow = true;
    group.add(roof);

    // Windows
    const windowMat = new THREE.MeshLambertMaterial({ color: 0x81D4FA, emissive: 0x29B6F6, emissiveIntensity: 0.2 });
    const windowSize = 1.2;
    const floors = Math.floor(h / 3.5);
    for (let floor = 0; floor < floors; floor++) {
        const wy = 2.5 + floor * 3.5;
        const numWindows = Math.floor(w / 3);
        for (let wi = 0; wi < numWindows; wi++) {
            const wx = -w / 2 + 1.5 + wi * 3;
            const winGeo = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
            const win = new THREE.Mesh(winGeo, windowMat);
            win.position.set(wx, wy, d / 2 + 0.05);
            group.add(win);

            const win2 = win.clone();
            win2.position.z = -d / 2 - 0.05;
            group.add(win2);
        }
    }

    group.position.set(x, 0, z);
    scene.add(group);
    buildings.push({ mesh: group, x: x, z: z, w: w + 2, d: d + 2 });
}

function createTemple(x, z, color) {
    const group = new THREE.Group();

    // Base platform
    const baseGeo = new THREE.BoxGeometry(16, 1, 16);
    const baseMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 0.5;
    base.castShadow = true;
    group.add(base);

    // Main structure
    const mainGeo = new THREE.BoxGeometry(12, 8, 12);
    const mainMat = new THREE.MeshLambertMaterial({ color: color });
    const main = new THREE.Mesh(mainGeo, mainMat);
    main.position.y = 5;
    main.castShadow = true;
    group.add(main);

    // Tiered roof (Thai style!)
    for (let tier = 0; tier < 4; tier++) {
        const size = 14 - tier * 3;
        const roofGeo = new THREE.ConeGeometry(size / 1.4, 2, 4);
        const roofMat = new THREE.MeshLambertMaterial({
            color: tier % 2 === 0 ? 0xFFD700 : 0xFF6F00
        });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 9 + tier * 2.2;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);
    }

    // Spire
    const spireGeo = new THREE.ConeGeometry(0.5, 5, 8);
    const spireMat = new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.3 });
    const spire = new THREE.Mesh(spireGeo, spireMat);
    spire.position.y = 20;
    group.add(spire);

    group.position.set(x, 0, z);
    scene.add(group);
    buildings.push({ mesh: group, x: x, z: z, w: 18, d: 18 });
}

function createTrees() {
    const hRoads = [-80, -30, 20, 70];
    const vRoads = [-80, -30, 20, 70];

    // Trees along roads
    hRoads.forEach(z => {
        for (let x = -100; x <= 100; x += 15 + Math.random() * 10) {
            if (!isNearRoad(x, z + ROAD_WIDTH / 2 + 4, 3)) continue;
            createPalmTree(x + Math.random() * 3, z + ROAD_WIDTH / 2 + 3 + Math.random() * 2);
            createPalmTree(x + Math.random() * 3, z - ROAD_WIDTH / 2 - 3 - Math.random() * 2);
        }
    });

    vRoads.forEach(x => {
        for (let z = -100; z <= 100; z += 15 + Math.random() * 10) {
            createPalmTree(x + ROAD_WIDTH / 2 + 3 + Math.random() * 2, z + Math.random() * 3);
            createPalmTree(x - ROAD_WIDTH / 2 - 3 - Math.random() * 2, z + Math.random() * 3);
        }
    });
}

function createPalmTree(x, z) {
    // Check if too close to buildings
    for (const b of buildings) {
        if (Math.abs(x - b.x) < b.w / 2 + 2 && Math.abs(z - b.z) < b.d / 2 + 2) return;
    }

    const group = new THREE.Group();

    // Trunk (curved)
    const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8D6E63 });
    const lean = Math.random() * 0.2 - 0.1;
    for (let i = 0; i < 5; i++) {
        const segGeo = new THREE.CylinderGeometry(0.35 - i * 0.04, 0.4 - i * 0.04, 1.5, 6);
        const seg = new THREE.Mesh(segGeo, trunkMat);
        seg.position.set(lean * i, 0.75 + i * 1.4, 0);
        seg.castShadow = true;
        group.add(seg);
    }

    // Leaves (palm fronds)
    const leafMat = new THREE.MeshLambertMaterial({ color: 0x2E7D32, side: THREE.DoubleSide });
    const topY = 7.5;
    for (let i = 0; i < 7; i++) {
        const angle = (i / 7) * Math.PI * 2;
        const leafGeo = new THREE.ConeGeometry(0.8, 4, 4);
        const leaf = new THREE.Mesh(leafGeo, leafMat);
        leaf.position.set(
            lean * 5 + Math.cos(angle) * 1.5,
            topY + 0.5,
            Math.sin(angle) * 1.5
        );
        leaf.rotation.x = Math.sin(angle) * 0.8;
        leaf.rotation.z = -Math.cos(angle) * 0.8;
        leaf.castShadow = true;
        group.add(leaf);
    }

    // Coconuts!
    const cocoMat = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
    for (let i = 0; i < 3; i++) {
        const cocoGeo = new THREE.SphereGeometry(0.25, 6, 6);
        const coco = new THREE.Mesh(cocoGeo, cocoMat);
        const a = (i / 3) * Math.PI * 2;
        coco.position.set(lean * 5 + Math.cos(a) * 0.5, topY - 0.3, Math.sin(a) * 0.5);
        group.add(coco);
    }

    group.position.set(x, 0, z);
    scene.add(group);
    trees.push({ mesh: group, x: x, z: z, radius: 1 });
}

function createDecorations() {
    // Street food carts (very Thai!)
    const cartPositions = [
        { x: -75, z: -25 }, { x: 25, z: -75 }, { x: -25, z: 25 },
        { x: 75, z: 25 }, { x: -30, z: 75 }, { x: 65, z: -35 }
    ];

    cartPositions.forEach(pos => {
        const cart = createFoodCart();
        cart.position.set(pos.x, 0, pos.z);
        scene.add(cart);
        buildings.push({ mesh: cart, x: pos.x, z: pos.z, w: 4, d: 3 });
    });

    // Floating lanterns (decorative)
    for (let i = 0; i < 30; i++) {
        const lanternGeo = new THREE.SphereGeometry(0.4, 8, 8);
        const lanternMat = new THREE.MeshLambertMaterial({
            color: [0xFF6B9D, 0xFFD700, 0xFF8A65, 0xB39DDB, 0x81C784][Math.floor(Math.random() * 5)],
            emissive: 0xFF6B00,
            emissiveIntensity: 0.3
        });
        const lantern = new THREE.Mesh(lanternGeo, lanternMat);
        lantern.position.set(
            (Math.random() - 0.5) * MAP_SIZE,
            15 + Math.random() * 10,
            (Math.random() - 0.5) * MAP_SIZE
        );
        lantern.userData = { floatOffset: Math.random() * Math.PI * 2, floatSpeed: 0.5 + Math.random() * 0.5 };
        scene.add(lantern);
        decorations.push(lantern);
    }
}

function createFoodCart() {
    const group = new THREE.Group();

    // Cart body
    const bodyGeo = new THREE.BoxGeometry(3, 1.5, 2);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xFF8A65 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1;
    body.castShadow = true;
    group.add(body);

    // Umbrella
    const umbrellaGeo = new THREE.ConeGeometry(2.5, 1.5, 8);
    const umbrellaMat = new THREE.MeshLambertMaterial({ color: 0xFF1744 });
    const umbrella = new THREE.Mesh(umbrellaGeo, umbrellaMat);
    umbrella.position.y = 3.5;
    group.add(umbrella);

    // Pole
    const poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 2, 6);
    const poleMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.y = 2.5;
    group.add(pole);

    // Wheels
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    [-1, 1].forEach(side => {
        const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 12);
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(side * 1.3, 0.4, 1);
        group.add(wheel);
    });

    return group;
}

// ============ TUK-TUK CREATION ============
function createTukTuk() {
    tuktukGroup = new THREE.Group();

    // Main body (bright pink/magenta - very Thai!)
    const bodyGeo = new THREE.BoxGeometry(2.5, 1.5, 4);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xFF1493 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.2;
    body.castShadow = true;
    tuktukGroup.add(body);

    // Roof
    const roofGeo = new THREE.BoxGeometry(2.7, 0.2, 3.5);
    const roofMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(0, 2.2, -0.2);
    roof.castShadow = true;
    tuktukGroup.add(roof);

    // Roof supports
    const supportMat = new THREE.MeshLambertMaterial({ color: 0xCCCCCC });
    [[-1.1, -1.5], [1.1, -1.5], [-1.1, 1.2], [1.1, 1.2]].forEach(([x, z]) => {
        const supportGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 6);
        const support = new THREE.Mesh(supportGeo, supportMat);
        support.position.set(x, 1.8, z);
        tuktukGroup.add(support);
    });

    // Front (driver area - more narrow)
    const frontGeo = new THREE.BoxGeometry(1.8, 1.3, 1.2);
    const frontMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
    const front = new THREE.Mesh(frontGeo, frontMat);
    front.position.set(0, 1.1, 2.3);
    front.castShadow = true;
    tuktukGroup.add(front);

    // Windshield
    const windshieldGeo = new THREE.BoxGeometry(1.6, 0.8, 0.1);
    const windshieldMat = new THREE.MeshLambertMaterial({ color: 0x81D4FA, transparent: true, opacity: 0.6 });
    const windshield = new THREE.Mesh(windshieldGeo, windshieldMat);
    windshield.position.set(0, 1.8, 2.7);
    tuktukGroup.add(windshield);

    // Headlights
    const lightMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00, emissive: 0xFFFF00, emissiveIntensity: 0.5 });
    [-0.7, 0.7].forEach(x => {
        const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.set(x, 1.0, 2.9);
        tuktukGroup.add(light);
    });

    // Tail lights
    const tailMat = new THREE.MeshLambertMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 0.3 });
    [-0.9, 0.9].forEach(x => {
        const tailGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
        const tail = new THREE.Mesh(tailGeo, tailMat);
        tail.position.set(x, 0.9, -2.0);
        tuktukGroup.add(tail);
    });

    // Wheels
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
    // Front wheel
    const fWheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 12);
    const fWheel = new THREE.Mesh(fWheelGeo, wheelMat);
    fWheel.rotation.z = Math.PI / 2;
    fWheel.position.set(0, 0.4, 2.0);
    tuktukGroup.add(fWheel);

    // Rear wheels
    [-1.2, 1.2].forEach(x => {
        const rWheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.35, 12);
        const rWheel = new THREE.Mesh(rWheelGeo, wheelMat);
        rWheel.rotation.z = Math.PI / 2;
        rWheel.position.set(x, 0.45, -1.2);
        tuktukGroup.add(rWheel);
    });

    // Exhaust pipe
    const exhaustGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.6, 8);
    const exhaustMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
    const exhaust = new THREE.Mesh(exhaustGeo, exhaustMat);
    exhaust.rotation.x = Math.PI / 2;
    exhaust.position.set(1.0, 0.6, -2.1);
    tuktukGroup.add(exhaust);

    // Decorative elements (Thai style tassels)
    const tasselColors = [0xFF0000, 0xFFD700, 0x00FF00];
    tasselColors.forEach((color, i) => {
        const tasselGeo = new THREE.SphereGeometry(0.12, 6, 6);
        const tasselMat = new THREE.MeshLambertMaterial({ color: color });
        const tassel = new THREE.Mesh(tasselGeo, tasselMat);
        tassel.position.set(-0.6 + i * 0.6, 2.3, 1.8);
        tuktukGroup.add(tassel);
    });

    tuktukGroup.position.set(0, 0, 0);
    scene.add(tuktukGroup);
    tuktuk = tuktukGroup;
}

// ============ PASSENGER SYSTEM ============
function spawnPassengers(count, append = false) {
    // Clear existing passengers only if not appending
    if (!append) {
        passengers.forEach(p => scene.remove(p.mesh));
        passengers = [];
    }

    const hRoads = [-80, -30, 20, 70];
    const vRoads = [-80, -30, 20, 70];
    const allRoadEdges = [];

    hRoads.forEach(z => {
        for (let x = -90; x <= 90; x += 20) {
            allRoadEdges.push({ x: x, z: z + ROAD_WIDTH / 2 + 2 });
            allRoadEdges.push({ x: x, z: z - ROAD_WIDTH / 2 - 2 });
        }
    });
    vRoads.forEach(x => {
        for (let z = -90; z <= 90; z += 20) {
            allRoadEdges.push({ x: x + ROAD_WIDTH / 2 + 2, z: z });
            allRoadEdges.push({ x: x - ROAD_WIDTH / 2 - 2, z: z });
        }
    });

    // Shuffle and pick positions
    const shuffled = allRoadEdges.sort(() => Math.random() - 0.5);

    for (let i = 0; i < count && i < shuffled.length; i++) {
        const pos = shuffled[i];

        // Make sure not inside a building
        let blocked = false;
        for (const b of buildings) {
            if (Math.abs(pos.x - b.x) < b.w / 2 + 1 && Math.abs(pos.z - b.z) < b.d / 2 + 1) {
                blocked = true; break;
            }
        }
        if (blocked) continue;

        const passenger = createPassengerMesh(pos.x, pos.z);

        // Random destination on a different road edge
        let dest;
        do {
            dest = allRoadEdges[Math.floor(Math.random() * allRoadEdges.length)];
        } while (Math.abs(dest.x - pos.x) < 30 && Math.abs(dest.z - pos.z) < 30);

        const fare = 20 + Math.floor(Math.sqrt(
            Math.pow(dest.x - pos.x, 2) + Math.pow(dest.z - pos.z, 2)
        ) * 0.5);

        passengers.push({
            mesh: passenger,
            x: pos.x, z: pos.z,
            destX: dest.x, destZ: dest.z,
            fare: fare,
            bobOffset: Math.random() * Math.PI * 2
        });
    }
}

function createPassengerMesh(x, z) {
    const group = new THREE.Group();

    const skinColors = [0xFFCC80, 0xD7A86E, 0xFFB74D, 0xF5D0A9];
    const shirtColors = [0xFF6B9D, 0x7FDBFF, 0xFFD700, 0x69F0AE, 0xB39DDB, 0xFF8A65, 0x00BCD4, 0xE91E63];

    const skinColor = skinColors[Math.floor(Math.random() * skinColors.length)];
    const shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];

    // Body
    const bodyGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: shirtColor });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.0;
    body.castShadow = true;
    group.add(body);

    // Head
    const headGeo = new THREE.SphereGeometry(0.4, 8, 8);
    const headMat = new THREE.MeshLambertMaterial({ color: skinColor });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 2.0;
    head.castShadow = true;
    group.add(head);

    // Hair
    const hairGeo = new THREE.SphereGeometry(0.42, 8, 4, 0, Math.PI * 2, 0, Math.PI / 2);
    const hairMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
    const hair = new THREE.Mesh(hairGeo, hairMat);
    hair.position.y = 2.1;
    group.add(hair);

    // Waving arm
    const armGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 6);
    const armMat = new THREE.MeshLambertMaterial({ color: skinColor });
    const arm = new THREE.Mesh(armGeo, armMat);
    arm.position.set(0.6, 1.6, 0);
    arm.rotation.z = -Math.PI / 4;
    arm.userData.isArm = true;
    group.add(arm);

    // Exclamation mark above head (!)
    const exGeo = new THREE.BoxGeometry(0.15, 0.5, 0.15);
    const exMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00, emissive: 0xFFFF00, emissiveIntensity: 0.5 });
    const ex = new THREE.Mesh(exGeo, exMat);
    ex.position.y = 3.0;
    group.add(ex);

    const dotGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
    const dot = new THREE.Mesh(dotGeo, exMat);
    dot.position.y = 2.6;
    group.add(dot);

    // Circle platform (green = waiting)
    const ringGeo = new THREE.RingGeometry(0.8, 1.2, 16);
    const ringMat = new THREE.MeshLambertMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.05;
    group.add(ring);

    group.position.set(x, 0, z);
    scene.add(group);
    return group;
}

function createDropoffMarker(x, z) {
    if (dropoffMarker) scene.remove(dropoffMarker);

    const group = new THREE.Group();

    // Pulsing ring
    const ringGeo = new THREE.RingGeometry(1.5, 2.2, 16);
    const ringMat = new THREE.MeshLambertMaterial({ color: 0xFF4444, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.1;
    group.add(ring);

    // Inner ring
    const innerGeo = new THREE.RingGeometry(0.5, 1.0, 16);
    const innerMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
    const inner = new THREE.Mesh(innerGeo, innerMat);
    inner.rotation.x = -Math.PI / 2;
    inner.position.y = 0.15;
    group.add(inner);

    // Floating arrow pointing down
    const arrowGeo = new THREE.ConeGeometry(0.8, 2, 8);
    const arrowMat = new THREE.MeshLambertMaterial({ color: 0xFF4444, emissive: 0xFF0000, emissiveIntensity: 0.3 });
    const arrow = new THREE.Mesh(arrowGeo, arrowMat);
    arrow.position.y = 5;
    arrow.rotation.x = Math.PI; // Point down
    group.add(arrow);

    // Vertical beam
    const beamGeo = new THREE.CylinderGeometry(0.1, 0.1, 20, 8);
    const beamMat = new THREE.MeshLambertMaterial({ color: 0xFF4444, transparent: true, opacity: 0.3 });
    const beam = new THREE.Mesh(beamGeo, beamMat);
    beam.position.y = 10;
    group.add(beam);

    group.position.set(x, 0, z);
    scene.add(group);
    dropoffMarker = group;
    dropoffMarker.userData = { x: x, z: z };
}

// ============ AUDIO ============
function playSound(type) {
    if (!audioCtx) return;

    const now = audioCtx.currentTime;

    if (type === 'pickup') {
        // Happy ascending notes
        [0, 0.1, 0.2].forEach((delay, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = [523, 659, 784][i]; // C5, E5, G5
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.2, now + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);
            osc.start(now + delay);
            osc.stop(now + delay + 0.3);
        });
    } else if (type === 'dropoff') {
        // Cash register / success sound
        [0, 0.08, 0.16, 0.24].forEach((delay, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = [784, 988, 1175, 1568][i]; // G5, B5, D6, G6
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, now + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.4);
            osc.start(now + delay);
            osc.stop(now + delay + 0.4);
        });
    } else if (type === 'honk') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = 400;
        osc.type = 'square';
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'tick') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = 880;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'gameover') {
        [0, 0.2, 0.4, 0.6, 0.8].forEach((delay, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = [523, 493, 440, 392, 523][i];
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, now + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.5);
            osc.start(now + delay);
            osc.stop(now + delay + 0.5);
        });
    }
}

// ============ PARTICLES ============
function spawnParticles(x, y, z, color, count = 10) {
    for (let i = 0; i < count; i++) {
        const geo = new THREE.SphereGeometry(0.15 + Math.random() * 0.2, 6, 6);
        const mat = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 1 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        particles.push({
            mesh: mesh,
            vx: (Math.random() - 0.5) * 0.3,
            vy: 0.1 + Math.random() * 0.3,
            vz: (Math.random() - 0.5) * 0.3,
            life: 1.0,
            decay: 0.01 + Math.random() * 0.02
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.mesh.position.x += p.vx;
        p.mesh.position.y += p.vy;
        p.mesh.position.z += p.vz;
        p.vy -= 0.008; // gravity
        p.life -= p.decay;
        p.mesh.material.opacity = p.life;
        p.mesh.scale.setScalar(p.life);

        if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

// ============ COLLISION DETECTION ============
function isNearRoad(x, z, margin) {
    const hRoads = [-80, -30, 20, 70];
    const vRoads = [-80, -30, 20, 70];

    for (const rz of hRoads) {
        if (Math.abs(z - rz) < ROAD_WIDTH / 2 + margin) return true;
    }
    for (const rx of vRoads) {
        if (Math.abs(x - rx) < ROAD_WIDTH / 2 + margin) return true;
    }
    return false;
}

function checkBuildingCollision(x, z) {
    for (const b of buildings) {
        if (Math.abs(x - b.x) < b.w / 2 + 1.5 && Math.abs(z - b.z) < b.d / 2 + 1.5) {
            return true;
        }
    }
    for (const t of trees) {
        if (Math.abs(x - t.x) < t.radius + 1.0 && Math.abs(z - t.z) < t.radius + 1.0) {
            return true;
        }
    }
    return false;
}

// ============ GAME LOGIC ============
function handleInput(delta) {
    if (!gameRunning) return;

    // Acceleration
    if (keys['arrowup'] || keys['w']) {
        speed = Math.min(speed + acceleration, maxSpeed);
    } else if (keys['arrowdown'] || keys['s']) {
        speed = Math.max(speed - brakeForce, -maxSpeed * 0.5);
    } else {
        // Friction
        if (speed > 0) speed = Math.max(0, speed - friction);
        if (speed < 0) speed = Math.min(0, speed + friction);
    }

    // Turning (only when moving)
    if (Math.abs(speed) > 0.01) {
        const turnAmount = turnRate * (speed > 0 ? 1 : -1);
        if (keys['arrowleft'] || keys['a']) {
            tuktuk.rotation.y += turnAmount;
        }
        if (keys['arrowright'] || keys['d']) {
            tuktuk.rotation.y -= turnAmount;
        }
    }

    // Space bar for pickup/dropoff
    if (keys[' '] || keys['Space']) {
        keys[' '] = false;
        keys['Space'] = false;
        handlePickupDropoff();
    }

    // Move tuk-tuk
    const moveX = Math.sin(tuktuk.rotation.y) * speed;
    const moveZ = Math.cos(tuktuk.rotation.y) * speed;

    const newX = tuktuk.position.x + moveX;
    const newZ = tuktuk.position.z + moveZ;

    // Collision check
    if (!checkBuildingCollision(newX, newZ)) {
        // Boundary check
        const boundary = MAP_SIZE * 0.7;
        if (Math.abs(newX) < boundary && Math.abs(newZ) < boundary) {
            tuktuk.position.x = newX;
            tuktuk.position.z = newZ;
        } else {
            speed *= -0.3; // Bounce back
        }
    } else {
        speed *= -0.5; // Bounce off buildings
        playSound('honk');
    }

    // Exhaust particles when moving
    if (Math.abs(speed) > 0.2 && Math.random() < 0.3) {
        const behindX = tuktuk.position.x - Math.sin(tuktuk.rotation.y) * 2.5;
        const behindZ = tuktuk.position.z - Math.cos(tuktuk.rotation.y) * 2.5;
        spawnParticles(behindX, 0.5, behindZ, 0x888888, 1);
    }
}

function handlePickupDropoff() {
    if (currentPassenger) {
        // Try to drop off
        if (nearDropoff) {
            dropoffPassenger();
        }
    } else {
        // Try to pick up
        if (nearbyPassenger !== null) {
            pickupPassenger(nearbyPassenger);
        }
    }
}

function pickupPassenger(index) {
    const p = passengers[index];
    currentPassenger = p;
    scene.remove(p.mesh);

    // Create dropoff marker
    createDropoffMarker(p.destX, p.destZ);

    // Show mission banner
    showBanner(`üßë Passenger picked up! Fare: ‡∏ø${p.fare}`);
    playSound('pickup');
    spawnParticles(p.x, 2, p.z, 0x00FF00, 15);

    // Remove from available passengers
    passengers.splice(index, 1);

    document.getElementById('pickup-prompt').classList.remove('show');
}

function dropoffPassenger() {
    if (!currentPassenger) return;

    // Combo system
    comboCount++;
    comboTimer = 5;

    let fareMultiplier = 1;
    let comboText = '';
    if (comboCount >= 5) { fareMultiplier = 2.0; comboText = 'üî• 5x COMBO! DOUBLE FARE!'; }
    else if (comboCount >= 3) { fareMultiplier = 1.5; comboText = '‚≠ê 3x COMBO! +50% FARE!'; }
    else if (comboCount >= 2) { fareMultiplier = 1.2; comboText = '‚ú® 2x COMBO! +20% FARE!'; }

    const earned = Math.floor(currentPassenger.fare * fareMultiplier);
    money += earned;
    passengersDelivered++;

    showBanner(`üí∞ Delivered! Earned ‡∏ø${earned}!`);
    if (comboText) showCombo(comboText);

    playSound('dropoff');
    spawnParticles(currentPassenger.destX, 2, currentPassenger.destZ, 0xFFD700, 20);

    // Update UI
    updateHUD();

    // Remove dropoff marker
    if (dropoffMarker) {
        scene.remove(dropoffMarker);
        dropoffMarker = null;
    }
    currentPassenger = null;

    // Spawn a replacement passenger
    setTimeout(() => {
        if (gameRunning) spawnPassengers(1, true);
    }, 2000);
}

function checkProximity() {
    const tx = tuktuk.position.x;
    const tz = tuktuk.position.z;
    const pickupPrompt = document.getElementById('pickup-prompt');

    // Check nearby passengers for pickup
    nearbyPassenger = null;
    if (!currentPassenger) {
        for (let i = 0; i < passengers.length; i++) {
            const p = passengers[i];
            const dist = Math.sqrt(Math.pow(tx - p.x, 2) + Math.pow(tz - p.z, 2));
            if (dist < 5) {
                nearbyPassenger = i;
                pickupPrompt.textContent = `Press SPACE to pick up! (Fare: ‡∏ø${p.fare}) üõ∫`;
                pickupPrompt.classList.add('show');
                break;
            }
        }
        if (nearbyPassenger === null) {
            pickupPrompt.classList.remove('show');
        }
    }

    // Check dropoff proximity
    nearDropoff = false;
    if (currentPassenger && dropoffMarker) {
        const dx = tx - dropoffMarker.userData.x;
        const dz = tz - dropoffMarker.userData.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < 6) {
            nearDropoff = true;
            pickupPrompt.textContent = 'Press SPACE to drop off! üéØ';
            pickupPrompt.classList.add('show');
            pickupPrompt.style.background = 'rgba(200, 0, 0, 0.85)';
            pickupPrompt.style.borderColor = '#FF4444';
        } else {
            pickupPrompt.classList.remove('show');
            pickupPrompt.style.background = 'rgba(0, 200, 0, 0.85)';
            pickupPrompt.style.borderColor = '#00FF00';
        }
    }
}

// ============ CAMERA ============
function updateCamera() {
    const cameraDistance = 18;
    const cameraHeight = 14;
    const lookAhead = 5;

    const targetX = tuktuk.position.x - Math.sin(tuktuk.rotation.y) * cameraDistance;
    const targetZ = tuktuk.position.z - Math.cos(tuktuk.rotation.y) * cameraDistance;

    camera.position.x += (targetX - camera.position.x) * 0.05;
    camera.position.y += (cameraHeight - camera.position.y) * 0.05;
    camera.position.z += (targetZ - camera.position.z) * 0.05;

    const lookX = tuktuk.position.x + Math.sin(tuktuk.rotation.y) * lookAhead;
    const lookZ = tuktuk.position.z + Math.cos(tuktuk.rotation.y) * lookAhead;
    camera.lookAt(lookX, 1, lookZ);
}

// ============ MINIMAP ============
function updateMinimap() {
    const canvas = document.getElementById('minimap-canvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const scale = 0.5;

    ctx.clearRect(0, 0, w, h);

    // Background
    ctx.fillStyle = '#2E7D32';
    ctx.beginPath();
    ctx.arc(cx, cy, 88, 0, Math.PI * 2);
    ctx.fill();

    // Roads
    ctx.fillStyle = '#555';
    const hRoads = [-80, -30, 20, 70];
    const vRoads = [-80, -30, 20, 70];
    const px = tuktuk.position.x;
    const pz = tuktuk.position.z;

    hRoads.forEach(rz => {
        const ry = cy + (rz - pz) * scale;
        ctx.fillRect(0, ry - 3, w, 6);
    });
    vRoads.forEach(rx => {
        const rxp = cx + (rx - px) * scale;
        ctx.fillRect(rxp - 3, 0, 6, h);
    });

    // Passengers (green dots)
    passengers.forEach(p => {
        const ppx = cx + (p.x - px) * scale;
        const ppy = cy + (p.z - pz) * scale;
        if (ppx > 5 && ppx < w - 5 && ppy > 5 && ppy < h - 5) {
            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(ppx, ppy, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    // Dropoff (red dot)
    if (dropoffMarker) {
        const dpx = cx + (dropoffMarker.userData.x - px) * scale;
        const dpy = cy + (dropoffMarker.userData.z - pz) * scale;
        ctx.fillStyle = '#FF4444';
        ctx.beginPath();
        ctx.arc(dpx, dpy, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#FFFF00';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Player (center, with direction)
    ctx.fillStyle = '#FF1493';
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fill();

    // Direction indicator
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(
        cx + Math.sin(tuktuk.rotation.y) * 12,
        cy + Math.cos(tuktuk.rotation.y) * 12
    );
    ctx.stroke();

    // Circular mask
    ctx.globalCompositeOperation = 'destination-in';
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(cx, cy, 88, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
}

// ============ UI ============
function updateHUD() {
    document.getElementById('money-display').textContent = `üí∞ ‡∏ø${money}`;

    const mins = Math.floor(timeLeft / 60);
    const secs = Math.floor(timeLeft % 60);
    document.getElementById('timer-display').textContent = `‚è±Ô∏è ${mins}:${secs.toString().padStart(2, '0')}`;

    if (timeLeft <= 15) {
        document.getElementById('timer-display').style.color = '#FF0000';
        document.getElementById('timer-display').style.animation = 'bounce 0.5s ease-in-out infinite';
    }

    document.getElementById('passengers-display').textContent = `üßë ${passengersDelivered} delivered`;
}

function showBanner(text) {
    const banner = document.getElementById('mission-banner');
    banner.textContent = text;
    banner.classList.add('show');
    setTimeout(() => banner.classList.remove('show'), 2500);
}

function showCombo(text) {
    const combo = document.getElementById('combo-display');
    combo.textContent = text;
    combo.classList.add('show');
    setTimeout(() => {
        combo.classList.remove('show');
    }, 2000);
}

// ============ ANIMATION LOOP ============
function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    const time = clock.getElapsedTime();

    if (gameRunning) {
        // Timer
        timeLeft -= delta;
        if (timeLeft <= 0) {
            timeLeft = 0;
            endGame();
        }

        // Combo decay
        if (comboTimer > 0) {
            comboTimer -= delta;
            if (comboTimer <= 0) {
                comboCount = 0;
            }
        }

        handleInput(delta);
        checkProximity();
        updateCamera();
        updateHUD();
        updateMinimap();
    } else if (!gameStarted) {
        // Title screen camera rotation
        camera.position.set(
            Math.sin(time * 0.3) * 40,
            25,
            Math.cos(time * 0.3) * 40
        );
        camera.lookAt(0, 0, 0);
    }

    // Animate passengers (bobbing, waving)
    passengers.forEach(p => {
        if (p.mesh) {
            p.mesh.position.y = Math.sin(time * 3 + p.bobOffset) * 0.15;
            // Make them face the tuk-tuk if nearby
            if (tuktuk) {
                const dx = tuktuk.position.x - p.x;
                const dz = tuktuk.position.z - p.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 15) {
                    p.mesh.rotation.y = Math.atan2(dx, dz);
                }
            }
        }
    });

    // Animate dropoff marker
    if (dropoffMarker) {
        dropoffMarker.children.forEach((child, i) => {
            if (i === 0) { // Outer ring
                child.scale.setScalar(1 + Math.sin(time * 3) * 0.2);
                child.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
            }
            if (i === 2) { // Arrow
                child.position.y = 4 + Math.sin(time * 4) * 1;
            }
        });
    }

    // Animate decorative lanterns
    decorations.forEach(d => {
        if (d.userData.floatOffset !== undefined) {
            d.position.y += Math.sin(time * d.userData.floatSpeed + d.userData.floatOffset) * 0.002;
        }
    });

    // Tuk-tuk tilt based on turning
    if (tuktuk && gameRunning) {
        const tiltTarget = 0;
        if (keys['arrowleft'] || keys['a']) tuktuk.rotation.z = THREE.MathUtils.lerp(tuktuk.rotation.z, 0.1, 0.1);
        else if (keys['arrowright'] || keys['d']) tuktuk.rotation.z = THREE.MathUtils.lerp(tuktuk.rotation.z, -0.1, 0.1);
        else tuktuk.rotation.z = THREE.MathUtils.lerp(tuktuk.rotation.z, 0, 0.1);

        // Bob when moving
        if (Math.abs(speed) > 0.1) {
            tuktuk.position.y = Math.sin(time * 10) * 0.05 * Math.abs(speed);
        }
    }

    updateParticles();

    renderer.render(scene, camera);
}

// ============ GAME STATE MANAGEMENT ============
function startGame() {
    if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    document.getElementById('title-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    document.getElementById('minimap').style.display = 'block';

    gameStarted = true;
    gameRunning = true;
    money = 0;
    passengersDelivered = 0;
    timeLeft = GAME_DURATION;
    speed = 0;
    comboCount = 0;
    comboTimer = 0;
    currentPassenger = null;

    if (dropoffMarker) {
        scene.remove(dropoffMarker);
        dropoffMarker = null;
    }

    // Reset tuk-tuk position
    tuktuk.position.set(0, 0, -30);
    tuktuk.rotation.set(0, 0, 0);

    showBanner('üõ∫ Pick up passengers and deliver them!\n Drive safe and earn ‡∏ø‡∏ø‡∏ø!');
    playSound('pickup');

    updateHUD();
}

function endGame() {
    gameRunning = false;
    playSound('gameover');

    document.getElementById('final-money').textContent = `‡∏ø${money}`;
    document.getElementById('final-passengers').textContent = passengersDelivered;

    // Rating
    let rating;
    if (money >= 500) rating = '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Tuk-Tuk Legend!';
    else if (money >= 350) rating = '‚≠ê‚≠ê‚≠ê‚≠ê Amazing Driver!';
    else if (money >= 200) rating = '‚≠ê‚≠ê‚≠ê Great Job!';
    else if (money >= 100) rating = '‚≠ê‚≠ê Good Start!';
    else rating = '‚≠ê Keep Practicing!';

    document.getElementById('final-rating').textContent = rating;
    document.getElementById('gameover-screen').classList.add('show');
}

function restartGame() {
    document.getElementById('gameover-screen').classList.remove('show');
    document.getElementById('timer-display').style.color = '#FF6B9D';
    document.getElementById('timer-display').style.animation = 'none';
    document.getElementById('pickup-prompt').classList.remove('show');

    // Clear passengers and respawn
    passengers.forEach(p => scene.remove(p.mesh));
    passengers = [];
    if (dropoffMarker) {
        scene.remove(dropoffMarker);
        dropoffMarker = null;
    }
    currentPassenger = null;

    // Clear particles
    particles.forEach(p => scene.remove(p.mesh));
    particles = [];

    spawnPassengers(8);
    startGame();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ============ START ============
init();
</script>

</body>
</html>
