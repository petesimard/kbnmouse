<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rainbow Unicorn Jump!</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Comic Sans MS', 'Chalkboard SE', cursive, sans-serif; }
    canvas { display: block; }

    #overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; pointer-events: auto;
      background: linear-gradient(135deg, rgba(255,100,150,0.85), rgba(100,150,255,0.85), rgba(150,255,100,0.85));
    }
    #overlay.hidden { display: none; }

    #title {
      font-size: clamp(2rem, 6vw, 5rem); color: #fff; text-shadow: 4px 4px 0 #ff69b4, -2px -2px 0 #8b5cf6;
      margin-bottom: 20px; text-align: center; animation: bounce 1s ease infinite alternate;
    }
    @keyframes bounce { 0% { transform: translateY(0); } 100% { transform: translateY(-15px); } }

    .subtitle {
      font-size: clamp(1rem, 3vw, 2rem); color: #fff; text-shadow: 2px 2px 0 #6366f1;
      margin-bottom: 10px; text-align: center; max-width: 80%;
    }

    #startBtn {
      margin-top: 30px; padding: 18px 50px;
      font-size: clamp(1.2rem, 3vw, 2rem); font-family: inherit;
      background: linear-gradient(135deg, #ff69b4, #8b5cf6);
      color: #fff; border: 4px solid #fff; border-radius: 50px;
      cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    #startBtn:hover { transform: scale(1.1); box-shadow: 0 8px 30px rgba(0,0,0,0.4); }

    #hud {
      position: fixed; top: 0; left: 0; width: 100%; padding: 15px 25px;
      display: flex; justify-content: space-between; align-items: center;
      z-index: 50; pointer-events: none;
    }
    #hud.hidden { display: none; }

    .hud-item {
      font-size: clamp(1.2rem, 3vw, 2.2rem); color: #fff;
      text-shadow: 3px 3px 0 rgba(0,0,0,0.5);
      background: rgba(0,0,0,0.3); padding: 8px 20px; border-radius: 25px;
    }

    #gameOver {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; pointer-events: auto;
      background: rgba(0,0,0,0.7);
    }
    #gameOver.hidden { display: none; }

    #gameOverTitle {
      font-size: clamp(2rem, 6vw, 4.5rem); color: #ff69b4;
      text-shadow: 3px 3px 0 #8b5cf6; margin-bottom: 15px;
    }
    #finalScore {
      font-size: clamp(1.5rem, 4vw, 3rem); color: #fff;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.5); margin-bottom: 30px;
    }

    #unicornEmoji {
      font-size: clamp(4rem, 10vw, 8rem); margin-bottom: 10px;
      animation: spin 2s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

<!-- Start Screen -->
<div id="overlay">
  <div id="unicornEmoji">ðŸ¦„</div>
  <div id="title">Rainbow Unicorn Jump!</div>
  <div class="subtitle">Jump over the flying 67s!</div>
  <div class="subtitle">Press SPACE or UP or W or TAP to jump!</div>
  <button id="startBtn" onclick="startGame()">Play!</button>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
  <div class="hud-item" id="scoreDisplay">Score: 0</div>
  <div class="hud-item" id="highScoreDisplay">Best: 0</div>
</div>

<!-- Game Over -->
<div id="gameOver" class="hidden">
  <div id="gameOverTitle">Oh no!</div>
  <div id="finalScore">Score: 0</div>
  <button id="startBtn" onclick="startGame()">Play Again!</button>
</div>

<script>
// ============ AUDIO ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playTone(freq, duration, type = 'square', vol = 0.15) {
  ensureAudio();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playJumpSound() { playTone(600, 0.15, 'sine', 0.2); setTimeout(() => playTone(900, 0.1, 'sine', 0.15), 80); }
function playScoreSound() { playTone(880, 0.1, 'sine', 0.12); setTimeout(() => playTone(1100, 0.15, 'sine', 0.1), 60); }
function playHitSound() { playTone(200, 0.3, 'sawtooth', 0.2); setTimeout(() => playTone(120, 0.4, 'sawtooth', 0.15), 100); }

// ============ THREE.JS SETUP ============
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

camera.position.set(0, 4, 12);
camera.lookAt(0, 2, 0);

// ============ LIGHTING ============
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 15, 10);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 50;
dirLight.shadow.camera.left = -15;
dirLight.shadow.camera.right = 15;
dirLight.shadow.camera.top = 15;
dirLight.shadow.camera.bottom = -5;
scene.add(dirLight);

// ============ SKY / BACKGROUND ============
function createSky() {
  const skyGeo = new THREE.SphereGeometry(100, 32, 32);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x87ceeb) },
      bottomColor: { value: new THREE.Color(0xfff0f5) },
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPos.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(h, 0.0)), 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));
}
createSky();

// ============ RAINBOW COLORS ============
const RAINBOW = [0xff0000, 0xff7700, 0xffff00, 0x00cc00, 0x0066ff, 0x4b0082, 0x9400d3];

// ============ GROUND ============
function createGround() {
  const geo = new THREE.PlaneGeometry(200, 40);
  const mat = new THREE.MeshStandardMaterial({
    color: 0x77dd77,
    roughness: 0.8
  });
  const ground = new THREE.Mesh(geo, mat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = 0;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grass tufts
  for (let i = 0; i < 60; i++) {
    const x = (Math.random() - 0.5) * 40;
    const z = (Math.random() - 0.5) * 10;
    const tGeo = new THREE.ConeGeometry(0.1, 0.4 + Math.random() * 0.3, 4);
    const tMat = new THREE.MeshStandardMaterial({ color: 0x55bb55 });
    const tuft = new THREE.Mesh(tGeo, tMat);
    tuft.position.set(x, 0.15, z);
    scene.add(tuft);
  }
}
createGround();

// ============ CLOUDS ============
const clouds = [];
function createCloud(x, y, z) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 });
  for (let i = 0; i < 5; i++) {
    const geo = new THREE.SphereGeometry(0.5 + Math.random() * 0.8, 8, 8);
    const puff = new THREE.Mesh(geo, mat);
    puff.position.set((Math.random() - 0.5) * 2, Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
    group.add(puff);
  }
  group.position.set(x, y, z);
  scene.add(group);
  clouds.push(group);
  return group;
}
for (let i = 0; i < 10; i++) {
  createCloud((Math.random() - 0.5) * 50, 8 + Math.random() * 8, -10 - Math.random() * 15);
}

// ============ RAINBOW ARC (background) ============
function createRainbowArc() {
  RAINBOW.forEach((color, i) => {
    const curve = new THREE.EllipseCurve(0, 0, 18 + i * 0.5, 12 + i * 0.5, 0, Math.PI, false, 0);
    const points = curve.getPoints(50);
    const geo = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, p.y, 0)));
    const mat = new THREE.LineBasicMaterial({ color, linewidth: 2 });
    const line = new THREE.Line(geo, mat);
    line.position.set(0, 0, -30);
    scene.add(line);
  });
}
createRainbowArc();

// ============ UNICORN ============
let unicorn;
let unicornVelY = 0;
let isOnGround = true;
const GRAVITY = -25;
const JUMP_VEL = 16.5;
const GROUND_Y = 0;

function createUnicorn() {
  unicorn = new THREE.Group();

  // Body (cylinder + sphere caps since CapsuleGeometry not in r128)
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.1 });
  const bodyCyl = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.4, 16), bodyMat);
  bodyCyl.rotation.z = Math.PI / 2;
  bodyCyl.position.y = 1.2;
  bodyCyl.castShadow = true;
  unicorn.add(bodyCyl);
  // Front cap
  const frontCap = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), bodyMat);
  frontCap.position.set(0.7, 1.2, 0);
  frontCap.castShadow = true;
  unicorn.add(frontCap);
  // Rear cap
  const rearCap = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), bodyMat);
  rearCap.position.set(-0.7, 1.2, 0);
  rearCap.castShadow = true;
  unicorn.add(rearCap);

  // Head
  const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.set(1.0, 1.8, 0);
  head.castShadow = true;
  unicorn.add(head);

  // Snout
  const snoutGeo = new THREE.SphereGeometry(0.25, 12, 12);
  snoutGeo.scale(1, 0.7, 0.8);
  const snout = new THREE.Mesh(snoutGeo, headMat);
  snout.position.set(1.4, 1.65, 0);
  unicorn.add(snout);

  // Eyes
  const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
  [-0.2, 0.2].forEach(z => {
    const eyeWhite = new THREE.Mesh(new THREE.SphereGeometry(0.14, 8, 8), eyeWhiteMat);
    eyeWhite.position.set(1.35, 1.95, z);
    unicorn.add(eyeWhite);
    const eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(1.42, 1.96, z);
    unicorn.add(eye);
  });

  // Sparkle eye highlights
  const sparkleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 });
  [-0.2, 0.2].forEach(z => {
    const sparkle = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), sparkleMat);
    sparkle.position.set(1.45, 1.99, z + 0.04);
    unicorn.add(sparkle);
  });

  // Horn (rainbow spiral)
  const hornGroup = new THREE.Group();
  const hornGeo = new THREE.ConeGeometry(0.12, 1.0, 8);
  const hornMat = new THREE.MeshStandardMaterial({
    color: 0xffd700,
    emissive: 0xffaa00,
    emissiveIntensity: 0.3,
    metalness: 0.8,
    roughness: 0.2
  });
  const horn = new THREE.Mesh(hornGeo, hornMat);
  horn.castShadow = true;
  hornGroup.add(horn);

  // Rainbow rings on horn
  for (let i = 0; i < 5; i++) {
    const ringGeo = new THREE.TorusGeometry(0.1 - i * 0.012, 0.02, 6, 12);
    const ringMat = new THREE.MeshStandardMaterial({ color: RAINBOW[i], emissive: RAINBOW[i], emissiveIntensity: 0.3 });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.y = -0.3 + i * 0.15;
    ring.rotation.x = Math.PI / 2;
    hornGroup.add(ring);
  }

  hornGroup.position.set(1.15, 2.55, 0);
  hornGroup.rotation.z = 0.2;
  unicorn.add(hornGroup);

  // Ears
  const earGeo = new THREE.ConeGeometry(0.12, 0.3, 6);
  const earMat = new THREE.MeshStandardMaterial({ color: 0xffccdd });
  [-0.2, 0.2].forEach(z => {
    const ear = new THREE.Mesh(earGeo, earMat);
    ear.position.set(0.85, 2.25, z);
    ear.rotation.z = z > 0 ? -0.3 : 0.3;
    unicorn.add(ear);
  });

  // Legs
  const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.7, 8);
  const legMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });
  const hoofGeo = new THREE.CylinderGeometry(0.13, 0.14, 0.12, 8);
  const hoofMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.3 });

  const legPositions = [
    [0.5, 0.45, 0.25], [0.5, 0.45, -0.25],
    [-0.5, 0.45, 0.25], [-0.5, 0.45, -0.25]
  ];
  unicorn.legs = [];
  legPositions.forEach(pos => {
    const legGroup = new THREE.Group();
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.castShadow = true;
    legGroup.add(leg);
    const hoof = new THREE.Mesh(hoofGeo, hoofMat);
    hoof.position.y = -0.38;
    legGroup.add(hoof);
    legGroup.position.set(...pos);
    unicorn.add(legGroup);
    unicorn.legs.push(legGroup);
  });

  // Rainbow mane
  unicorn.maneStrands = [];
  for (let i = 0; i < 7; i++) {
    const strand = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 8, 8),
      new THREE.MeshStandardMaterial({
        color: RAINBOW[i],
        emissive: RAINBOW[i],
        emissiveIntensity: 0.2
      })
    );
    strand.position.set(0.6 - i * 0.2, 2.0 + Math.sin(i * 0.5) * 0.15, 0);
    unicorn.add(strand);
    unicorn.maneStrands.push(strand);
  }

  // Rainbow tail
  unicorn.tailStrands = [];
  for (let i = 0; i < 7; i++) {
    const strand = new THREE.Mesh(
      new THREE.SphereGeometry(0.12, 8, 8),
      new THREE.MeshStandardMaterial({
        color: RAINBOW[i],
        emissive: RAINBOW[i],
        emissiveIntensity: 0.3
      })
    );
    strand.position.set(-1.2 - i * 0.15, 1.2 + Math.sin(i * 0.7) * 0.2, 0);
    unicorn.add(strand);
    unicorn.tailStrands.push(strand);
  }

  unicorn.position.set(-3, GROUND_Y, 0);
  scene.add(unicorn);
}

// ============ FLYING 67s ============
const obstacles = [];
const OBSTACLE_SPEED_BASE = 6;
let obstacleSpeed = OBSTACLE_SPEED_BASE;
let spawnTimer = 0;
let spawnInterval = 2.0;

function create67() {
  const group = new THREE.Group();

  // Create "67" as 3D text using box shapes since we can't load fonts
  // Let's make a chunky "6" and "7"

  const mat67 = new THREE.MeshStandardMaterial({
    color: 0xff4444,
    emissive: 0xff2222,
    emissiveIntensity: 0.3,
    metalness: 0.3,
    roughness: 0.4
  });

  // Use shapes made of boxes for "6" and "7"
  // "6" - approximate with curved boxes
  const sixGroup = new THREE.Group();
  const boxW = 0.18, boxH = 0.18, boxD = 0.3;

  // "6" - top horizontal
  addBox(sixGroup, mat67, 0, 0.7, 0, 0.5, boxH, boxD);
  // "6" - left vertical top
  addBox(sixGroup, mat67, -0.22, 0.45, 0, boxW, 0.5, boxD);
  // "6" - left vertical bottom
  addBox(sixGroup, mat67, -0.22, -0.1, 0, boxW, 0.6, boxD);
  // "6" - middle horizontal
  addBox(sixGroup, mat67, 0, 0.15, 0, 0.5, boxH, boxD);
  // "6" - bottom horizontal
  addBox(sixGroup, mat67, 0, -0.4, 0, 0.5, boxH, boxD);
  // "6" - right vertical bottom
  addBox(sixGroup, mat67, 0.22, -0.1, 0, boxW, 0.5, boxD);

  sixGroup.position.x = -0.5;
  group.add(sixGroup);

  // "7" - approximate
  const sevenGroup = new THREE.Group();
  // "7" - top horizontal
  addBox(sevenGroup, mat67, 0, 0.7, 0, 0.5, boxH, boxD);
  // "7" - right side short
  addBox(sevenGroup, mat67, 0.22, 0.55, 0, boxW, 0.25, boxD);
  // "7" - diagonal (approximate with angled boxes)
  for (let i = 0; i < 5; i++) {
    const t = i / 4;
    addBox(sevenGroup, mat67, 0.15 - t * 0.25, 0.45 - t * 1.1, 0, boxW, 0.3, boxD);
  }

  sevenGroup.position.x = 0.5;
  group.add(sevenGroup);

  // Wings!
  const wingMat = new THREE.MeshStandardMaterial({
    color: 0xffdd44,
    emissive: 0xffaa00,
    emissiveIntensity: 0.2,
    side: THREE.DoubleSide
  });

  // Left wing
  const wingShape = new THREE.Shape();
  wingShape.moveTo(0, 0);
  wingShape.bezierCurveTo(-0.5, 0.8, -1.2, 0.6, -1.0, 0);
  wingShape.bezierCurveTo(-0.8, -0.2, -0.3, -0.1, 0, 0);
  const wingGeo = new THREE.ShapeGeometry(wingShape);
  const leftWing = new THREE.Mesh(wingGeo, wingMat);
  leftWing.position.set(-0.9, 0.3, -0.2);
  leftWing.rotation.y = -0.3;
  group.add(leftWing);
  group.leftWing = leftWing;

  // Right wing
  const rightWing = new THREE.Mesh(wingGeo, wingMat);
  rightWing.position.set(-0.9, 0.3, 0.2);
  rightWing.rotation.y = 0.3;
  rightWing.scale.z = -1;
  group.add(rightWing);
  group.rightWing = rightWing;

  // Glow effect
  const glowGeo = new THREE.SphereGeometry(1.2, 8, 8);
  const glowMat = new THREE.MeshBasicMaterial({
    color: 0xff6644,
    transparent: true,
    opacity: 0.15
  });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  glow.position.y = 0.15;
  group.add(glow);

  // Random height
  const heightVariation = Math.random() * 2.0; // 0 to 2 â€” some fly low, some higher
  group.position.set(18, 1.0 + heightVariation, 0);
  group.scored = false;

  scene.add(group);
  obstacles.push(group);
  return group;
}

function addBox(parent, mat, x, y, z, w, h, d) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  parent.add(mesh);
}

// ============ PARTICLES ============
const particles = [];

function spawnParticles(x, y, z, color, count = 10) {
  for (let i = 0; i < count; i++) {
    const geo = new THREE.SphereGeometry(0.08 + Math.random() * 0.08, 6, 6);
    const mat = new THREE.MeshStandardMaterial({
      color: color || RAINBOW[Math.floor(Math.random() * RAINBOW.length)],
      emissive: color || RAINBOW[Math.floor(Math.random() * RAINBOW.length)],
      emissiveIntensity: 0.5
    });
    const p = new THREE.Mesh(geo, mat);
    p.position.set(x, y, z);
    p.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 5,
      Math.random() * 6,
      (Math.random() - 0.5) * 3
    );
    p.life = 0.8 + Math.random() * 0.5;
    p.maxLife = p.life;
    scene.add(p);
    particles.push(p);
  }
}

function spawnTrailParticle() {
  if (!unicorn || !gameActive) return;
  const color = RAINBOW[Math.floor(Math.random() * RAINBOW.length)];
  const geo = new THREE.SphereGeometry(0.06, 4, 4);
  const mat = new THREE.MeshBasicMaterial({
    color: color,
    transparent: true,
    opacity: 0.8
  });
  const p = new THREE.Mesh(geo, mat);
  p.position.set(
    unicorn.position.x - 1.2 + (Math.random() - 0.5) * 0.3,
    unicorn.position.y + 1.2 + (Math.random() - 0.5) * 0.5,
    (Math.random() - 0.5) * 0.5
  );
  p.velocity = new THREE.Vector3(-1 - Math.random(), (Math.random() - 0.5) * 2, (Math.random() - 0.5));
  p.life = 0.4 + Math.random() * 0.3;
  p.maxLife = p.life;
  scene.add(p);
  particles.push(p);
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= dt;
    if (p.life <= 0) {
      scene.remove(p);
      p.geometry.dispose();
      p.material.dispose();
      particles.splice(i, 1);
      continue;
    }
    p.position.add(p.velocity.clone().multiplyScalar(dt));
    p.velocity.y -= 5 * dt;
    const ratio = p.life / p.maxLife;
    p.material.opacity = ratio;
    p.scale.setScalar(ratio);
  }
}

// ============ STARS (decorative background sparkles) ============
const stars = [];
function createStars() {
  for (let i = 0; i < 30; i++) {
    const geo = new THREE.OctahedronGeometry(0.1, 0);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffaa,
      emissiveIntensity: 0.8
    });
    const star = new THREE.Mesh(geo, mat);
    star.position.set(
      (Math.random() - 0.5) * 40,
      5 + Math.random() * 15,
      -8 - Math.random() * 15
    );
    star.baseY = star.position.y;
    star.phase = Math.random() * Math.PI * 2;
    star.twinkleSpeed = 1 + Math.random() * 2;
    scene.add(star);
    stars.push(star);
  }
}
createStars();

// ============ GAME STATE ============
let gameActive = false;
let score = 0;
let highScore = parseInt(localStorage.getItem('unicorn67_highscore') || '0');
let gameTime = 0;
let trailTimer = 0;
let animTime = 0;

document.getElementById('highScoreDisplay').textContent = 'Best: ' + highScore;

// ============ CONTROLS ============
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
  if ((e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') && gameActive) {
    tryJump();
  }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch / click to jump
window.addEventListener('mousedown', e => {
  if (gameActive) tryJump();
});
window.addEventListener('touchstart', e => {
  if (gameActive) {
    e.preventDefault();
    tryJump();
  }
}, { passive: false });

function tryJump() {
  if (isOnGround && unicorn) {
    unicornVelY = JUMP_VEL;
    isOnGround = false;
    playJumpSound();
    spawnParticles(unicorn.position.x, unicorn.position.y + 0.2, 0, 0xffd700, 6);
  }
}

// ============ RESIZE ============
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============ COLLISION ============
function checkCollision(obs) {
  if (!unicorn) return false;
  // Simplified AABB collision
  const ux = unicorn.position.x;
  const uy = unicorn.position.y + 1.2; // center of unicorn body
  const ox = obs.position.x;
  const oy = obs.position.y + 0.15;

  const dx = Math.abs(ux - ox);
  const dy = Math.abs(uy - oy);

  return dx < 1.0 && dy < 0.9;
}

// ============ START / RESET ============
function startGame() {
  ensureAudio();

  // Clear obstacles
  obstacles.forEach(o => scene.remove(o));
  obstacles.length = 0;

  // Clear particles
  particles.forEach(p => {
    scene.remove(p);
    p.geometry.dispose();
    p.material.dispose();
  });
  particles.length = 0;

  // Reset unicorn
  if (unicorn) scene.remove(unicorn);
  createUnicorn();

  score = 0;
  gameTime = 0;
  spawnTimer = 0;
  spawnInterval = 2.2;
  obstacleSpeed = OBSTACLE_SPEED_BASE;
  unicornVelY = 0;
  isOnGround = true;
  gameActive = true;
  trailTimer = 0;

  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('gameOver').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('scoreDisplay').textContent = 'Score: 0';

  // Play a little start jingle
  playTone(523, 0.1, 'sine', 0.15);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.15), 100);
  setTimeout(() => playTone(784, 0.15, 'sine', 0.15), 200);
}

function endGame() {
  gameActive = false;
  playHitSound();

  // Explosion of particles
  if (unicorn) {
    spawnParticles(unicorn.position.x, unicorn.position.y + 1.2, 0, null, 30);
  }

  if (score > highScore) {
    highScore = score;
    localStorage.setItem('unicorn67_highscore', highScore.toString());
  }

  setTimeout(() => {
    document.getElementById('gameOver').classList.remove('hidden');
    document.getElementById('gameOverTitle').textContent = score > 10 ? 'Great Job!' : 'Oh no!';
    document.getElementById('finalScore').textContent = 'Score: ' + score + (score > highScore - 1 && score > 0 ? ' â­ New Best!' : '');
    document.getElementById('highScoreDisplay').textContent = 'Best: ' + highScore;
  }, 600);
}

// ============ GAME LOOP ============
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  animTime += dt;

  // Animate stars
  stars.forEach(s => {
    s.position.y = s.baseY + Math.sin(animTime * s.twinkleSpeed + s.phase) * 0.3;
    s.rotation.y += dt * 2;
    s.material.emissiveIntensity = 0.5 + Math.sin(animTime * s.twinkleSpeed * 2 + s.phase) * 0.4;
  });

  // Animate clouds
  clouds.forEach((c, i) => {
    c.position.x -= dt * 0.3 * (0.5 + i * 0.1);
    if (c.position.x < -30) c.position.x = 30;
  });

  if (gameActive && unicorn) {
    gameTime += dt;

    // Difficulty ramp
    obstacleSpeed = OBSTACLE_SPEED_BASE + gameTime * 0.15;
    spawnInterval = Math.max(0.9, 2.2 - gameTime * 0.03);

    // Unicorn physics
    unicornVelY += GRAVITY * dt;
    unicorn.position.y += unicornVelY * dt;

    if (unicorn.position.y <= GROUND_Y) {
      unicorn.position.y = GROUND_Y;
      unicornVelY = 0;
      isOnGround = true;
    }

    // Animate unicorn legs
    if (unicorn.legs) {
      const legSpeed = isOnGround ? 12 : 3;
      const legAmp = isOnGround ? 0.3 : 0.15;
      unicorn.legs.forEach((leg, i) => {
        leg.rotation.x = Math.sin(animTime * legSpeed + i * Math.PI * 0.5) * legAmp;
      });
    }

    // Animate mane
    if (unicorn.maneStrands) {
      unicorn.maneStrands.forEach((s, i) => {
        s.position.y = 2.0 + Math.sin(animTime * 4 + i * 0.8) * 0.15;
        s.position.x = 0.6 - i * 0.2 + Math.sin(animTime * 3 + i) * 0.05;
      });
    }

    // Animate tail
    if (unicorn.tailStrands) {
      unicorn.tailStrands.forEach((s, i) => {
        s.position.y = 1.2 + Math.sin(animTime * 3 + i * 0.7) * 0.2;
        s.position.x = -1.2 - i * 0.15 + Math.sin(animTime * 2.5 + i * 0.5) * 0.1;
      });
    }

    // Slight body bob
    unicorn.rotation.z = Math.sin(animTime * 5) * 0.03;

    // Trail particles
    trailTimer += dt;
    if (trailTimer > 0.04) {
      trailTimer = 0;
      spawnTrailParticle();
    }

    // Spawn obstacles
    spawnTimer += dt;
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      create67();
    }

    // Update obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      obs.position.x -= obstacleSpeed * dt;

      // Wing flap animation
      if (obs.leftWing) {
        const flapAngle = Math.sin(animTime * 8 + i) * 0.4;
        obs.leftWing.rotation.z = flapAngle;
        obs.rightWing.rotation.z = flapAngle;
      }

      // Bobbing
      obs.position.y += Math.sin(animTime * 3 + i * 2) * dt * 0.5;

      // Slight rotation
      obs.rotation.z = Math.sin(animTime * 2 + i) * 0.1;

      // Score check
      if (!obs.scored && obs.position.x < unicorn.position.x - 1.0) {
        obs.scored = true;
        score++;
        document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
        playScoreSound();
        spawnParticles(unicorn.position.x + 0.5, unicorn.position.y + 2.5, 0, 0xffff00, 5);
      }

      // Collision
      if (checkCollision(obs)) {
        endGame();
        break;
      }

      // Remove off-screen
      if (obs.position.x < -15) {
        scene.remove(obs);
        obstacles.splice(i, 1);
      }
    }
  }

  // Update particles
  updateParticles(dt);

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
